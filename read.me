Разработка заданий из ЛАБ 4 (проходила 2016-09-22)


1.    Реализуйте двухсвязный список, в котором значением каждого элемента является структура, 
      описывающай координаты точки на плоскости.
2.    Заполните список 20 случайными значениями.
3.    Реализуйте функцию поиска первого и последнего элемента, равного заданному.
4.    Реализуйте функцию вставки элемента в указанную позицию в списке.
5.    Реализуйте функцию удаления элемента из указанной позицию в списке.
6.    Реализуйте функцию, возвращающую все элементы списка, удовлетворяющие некоторому критерию, 
      в виде отдельного списка. Критерий должен передаваться как указатель на функцию, принимающую 
      в качестве параметра элемент списка.
7.    Используя код из предыдущего задания, рачечатайте первые 5 элементов списка, которые находятся 
      ближе всего к центру масс точек списка. Координаты центра масс вычисляются как среднее 
      арифметическое координат всех точек.



Заготовка:

#include <stdlib.h>
#include <iostream.h>

struct Node       //Структура являющаяся звеном списка
{
        int x;     //Значение x будет передаваться в список
        Node *next,*prev; //Указатели на адреса следующего и предыдущего элементов списка
};


struct List   //Создаем тип данных Список
{
        Node *head;
        Node *tail;  //Указатели на адреса начала списка и его конца
};


void add( List *list, int x )
{
        Node *temp = new Node(); // Выделение памяти под новый элемент структуры
        temp->next = NULL;       // Указываем, что изначально по следующему адресу пусто
        temp->x = x;             // Записываем значение в структуру

        if ( list->head != NULL ) // Если список не пуст
        {
                temp->prev = list->tail; // Указываем адрес на предыдущий элемент в соотв. поле
                list->tail->next = temp; // Указываем адрес следующего за хвостом элемента
                list->tail = temp;       //Меняем адрес хвоста
        }
        else //Если список пустой
        {
                temp->prev = NULL; // Предыдущий элемент указывает в пустоту
                list->head = list->tail = temp;    // Голова=Хвост=тот элемент, что сейчас добавили
        }
}

void print( List * list )
{
        Node * temp = list->head;  // Временно указываем на адрес первого элемента
        while( temp != NULL )      // Пока не встретим пустое значение
        {
                cout << temp->x <<" "; //Выводим значение на экран
                temp = temp->next;     //Смена адреса на адрес следующего элемента
        }
        cout<<"\n";
}

int main() {
        List list;
        list.head = list.tail = NULL;
        add( &list, 1 );
        add( &list, -1 )
        print( &list );
        return 0;
}